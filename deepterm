#!/usr/bin/env node

import readline from 'readline';
import readlinePrompt from 'readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import fs from 'fs';
import * as core from './deepterm-core.js';

const args = process.argv.slice(2);
const TOKEN = process.env.DEEPSEEK_TOKEN;

if (!TOKEN) {
  console.error('‚ùå Environment variable DEEPSEEK_TOKEN is not set.');
  process.exit(1);
}

let promptArg = null;
let outputFile = null;
let interactive = false;
let asciiLogo = `
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£¥‚£∂‚£æ‚£∑‚£∂‚£¶‚£Ñ‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ü‚†Ä
‚¢Ä‚£Ä‚£Ä‚£Ä‚£†‚£¥‚£æ‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü
‚†à‚†ª‚¢ø‚£ø‚£ø‚£ø‚°ø‚£ü‚†É‚†Ä‚£Ä‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ß
‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚¢ª‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ü‚†õ‚°ô‚†õ‚¢õ‚°ª‚†ã‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†í‚†Ñ‚†¨‚¢â‚£°‚£†‚£ø‚£ø‚£ø‚£á‚°å‚†≤‚††‚†ã‚†à‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚†Å‚†ÄDeepTerm
`;

for (let i = 0; i < args.length; i++) {
  const a = args[i];
  if (a === '-p' || a === '--prompt') {
    if (i + 1 < args.length) {
      promptArg = args[++i];
    } else {
      console.error('‚ùå Missing value for', a);
      process.exit(1);
    }
  } else if (a === '-i' || a === '--interactive') {
    interactive = true;
  } else if (a === '-o' || a === '--output') {
    if (i + 1 < args.length) {
      outputFile = args[++i];
    } else {
      console.error('‚ùå Missing value for', a);
      process.exit(1);
    }
  } else if (a === '-h' || a === '--help') {
    console.log(`Usage: deepterm [options]

Options:
  -p, --prompt "<text>"     Send one-shot prompt via CLI
  -i, --interactive         Start an interactive session
  -o, --output <file>       Save the response to a file
  -h, --help                Show this help message
`);
    process.exit(0);
  }
}

function aiBannerPrompt() {
  const line = '‚îÅ'.repeat(60);
  const banner = `‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
Type or paste your prompt below
[ESC] to send
[Ctrl+C] to exit
${line}
`;
  console.log(banner);
}

export async function interactiveCLI(CHAT_SESSION_ID, LAST_CHAT_ID) {
  let buffer = [];
  let currentLine = '';

  aiBannerPrompt();

  if (process.stdin.isTTY && typeof process.stdin.setRawMode === 'function') {
    process.stdin.setRawMode(true);
  }
  process.stdin.resume();
  readline.emitKeypressEvents(process.stdin);

  const onKeypress = async (str, key) => {
    try {
      if (key.name === 'return' || key.sequence === '\r') {
        buffer.push(currentLine);
        currentLine = '';
        process.stdout.write('\n');
      } else if (key.name === 'backspace') {
        if (currentLine.length > 0) {
          currentLine = currentLine.slice(0, -1);
          process.stdout.clearLine(0);
          process.stdout.cursorTo(0);
          process.stdout.write(currentLine);
        }
      } else if (key.name === 'escape') {
        buffer.push(currentLine);
        const prompt = buffer.join('\n').trim();
        currentLine = '';
        buffer = [];

        if (prompt) {
          console.log('\n\nü§ñ Response:\n');
          try {
            for await (let token of core.completion(TOKEN, prompt, CHAT_SESSION_ID, LAST_CHAT_ID)) {
              process.stdout.write(token);
            }
          } catch (e) {
            console.error('\n‚ùå Error while streaming response:', e.message || e);
          }
          console.log('\n\n' + '‚îÅ'.repeat(60) + '\n');
        } else {
          console.log('\n‚ùå Empty prompt.\n');
        }
      } else if (key.ctrl && key.name === 'c') {
        console.log('\nüëã Exiting.\n');
        cleanupAndExit();
      } else if (typeof str === 'string' && str !== '\u0000') {
        currentLine += str;
        process.stdout.write(str);
      }
    } catch (e) {
      console.error('‚ùå Error:', e.message || e);
    }
  };

  process.stdin.on('keypress', onKeypress);

  function cleanupAndExit(code = 0) {
    try {
      process.stdin.removeListener('keypress', onKeypress);
      if (process.stdin.isTTY && typeof process.stdin.setRawMode === 'function') {
        process.stdin.setRawMode(false);
      }
    } catch (e) {
    }
    process.exit(code);
  }

  process.on('SIGINT', () => cleanupAndExit(0));
  process.on('exit', () => {
    try {
      if (process.stdin.isTTY && typeof process.stdin.setRawMode === 'function') {
        process.stdin.setRawMode(false);
      }
    } catch (e) {}
  });
}

async function sendPrompt(promptText) {
  try {
    const session = await core.createChatSession(TOKEN);
    const chatId = session?.data?.biz_data?.id;
    const parentId = null;

    if (!chatId) {
      console.error('‚ùå Failed to create chat session.');
      process.exit(1);
    }

    let fullResponse = '';
    for await (const token of core.completion(TOKEN, promptText, chatId, parentId)) {
      process.stdout.write(token);
      fullResponse += token;
    }

    if (outputFile) {
      try {
        fs.writeFileSync(outputFile, fullResponse);
      } catch (e) {
        console.error('‚ùå Failed to write output file:', e.message || e);
      }
    }
  } catch (e) {
    console.error('‚ùå sendPrompt failed:', e.message || e);
    process.exit(1);
  }
}

async function runInteractiveMode() {
  try {
    console.clear();
    console.log(`${asciiLogo}\n`);
    const profile = await core.getCurrentProfile(TOKEN);
    if (!profile || typeof profile !== 'object') {
      console.log('‚ùå Failed to fetch user profile.');
      return;
    }

    const email = profile.data?.biz_data?.email;
    console.log(`Logged in as: ${email}\n`);

    if (profile.data?.biz_data?.chat?.is_muted === 1) {
      const ts = profile.data.biz_data.chat.mute_until;
      const date = new Date(ts * 1000);
      console.log('‚ö†Ô∏è You are currently muted!');
      console.log(`üîá Mute expires at: ${date.toString()}`);
      return;
    }

    const pages = await core.fetchAllChatSessions(TOKEN);
    if (!pages || typeof pages !== 'object') {
      console.log('‚ùå Failed to fetch chat sessions.');
      return;
    }

    const chats = pages.data?.biz_data?.chat_sessions || [];
    if (!Array.isArray(chats) || chats.length === 0) {
      console.log('‚ùå No chat sessions found.');
      return;
    }

    console.log('üí¨ Available chat sessions:\n');
    chats.forEach((chat, i) => {
      const title = chat.title || '(untitled)';
      console.log(`[${i + 1}] ${title}`);
    });
    console.log('[+] Start a new chat session');

    const rl = readlinePrompt.createInterface({ input, output });
    let ans;
    try {
      ans = await rl.question('\n‚û°Ô∏è Select a session or type + to create new:  ');
    } catch (e) {
      rl.close();
      return;
    }
    rl.close();

    if (ans === '+') {
      const newChat = await core.createChatSession(TOKEN);
      if (!newChat || typeof newChat !== 'object') {
        console.log('‚ùå Failed to create new session.');
        return;
      }
      console.clear();
      console.log(`${asciiLogo}\n\n‚úÖ New session started.`);
      await interactiveCLI(newChat.data.biz_data.id, null);
    } else {
      const idx = parseInt((ans || '').trim(), 10) - 1;
      if (isNaN(idx) || idx < 0 || idx >= chats.length) {
        console.log('‚ùå Invalid selection.');
        return;
      }
      const selectedChat = chats[idx];
      console.clear();
      console.log(`${asciiLogo}\n\n‚úÖ Using session: ${selectedChat.title}`);

      const chatId = selectedChat.id || selectedChat.chat_session_id || selectedChat._id || selectedChat.biz_data?.id;
      if (!chatId) {
        console.log('‚ùå Could not determine chat id for the selected session.');
        return;
      }

      const chat_session = await core.fetchHistoryMessages(TOKEN, chatId);
      if (!chat_session || typeof chat_session !== 'object') {
        console.log('‚ùå Failed to load messages.');
        return;
      }
      const list_msg = chat_session.data?.biz_data?.chat_messages || [];
      let last_msg_id = 0;
      if (list_msg.length !== 0) {
        const last_msg = list_msg[list_msg.length - 1];
        last_msg_id = last_msg.message_id || last_msg.id || 0;
      }
      console.log('üì® Resuming from the last message...');
      await interactiveCLI(chatId, last_msg_id);
    }
  } catch (e) {
    console.error('‚ùå runInteractiveMode failed:', e.message || e);
  }
}

(async () => {
  try {
    if (interactive || (!promptArg && process.stdin.isTTY)) {
      await runInteractiveMode();
    } else if (promptArg) {
      let finalPrompt = promptArg;
      if (!process.stdin.isTTY) {
        let inputText = '';
        for await (const chunk of process.stdin) {
          inputText += chunk;
        }
        finalPrompt += '\n\n' + inputText.trim();
      }
      await sendPrompt(finalPrompt);
    } else {
      let piped = '';
      for await (const chunk of process.stdin) {
        piped += chunk;
      }
      await sendPrompt(piped.trim());
    }
  } catch (e) {
    console.error('‚ùå Unexpected failure:', e.message || e);
    process.exit(1);
  }
})();
